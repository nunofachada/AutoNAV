{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Python package for simulating UAV Navigation in Satellite-Less Environments. The package contains two algorithms the GTRS [1] and WLS [2]  whose goal is to estimate and navigate a UAV.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install --upgrade pip\npip install autonav\n</code></pre>"},{"location":"#first-steps","title":"First Steps","text":"<p>After installing the package one can import the algorithms and necessary dependencies as follows:</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom autonav import gtrs, wls\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories\nfrom numpy import array\n</code></pre> <p>Afterwards, one can create the necessary values to run the algorithms:</p> <pre><code># Area border\nb = 200\n# Number of anchors\nn = 8\n# Position of the anchors\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\n# Number of measurement samples\nk = 50\n# Noise standard deviation\nsigma = 1\n# Maximum velocity allowed to the UAV\nv_max = b / 100\n# Distance threshold\ntau = b / 50\n# Smoothing factor\ngamma = b / 100\n# Initial position of the UAV\ninitial_uav_position = [10, 10, 5]\n# File containing the waypoints\ndestinations = readpathfile(\"docs/docs/examples/Path.csv\")\n</code></pre> <p>Finally, run the GTRS or WLS algorithm and plot the trajectories:</p> <pre><code># Estimate the trajectory using the GTRS algorithm\n[estimated_trajectory, true_trajectory] = gtrs(a_i, n, k, sigma, destinations, initial_uav_position, v_max, tau, gamma)\n# Plot the estimated trajectory\nplot_trajectories(destinations, [estimated_trajectory], a_i, ['GTRS'])\nplt.show()\n</code></pre> <p> </p>"},{"location":"#references","title":"References","text":"<p>[1] J. P. Matos-Carvalho, R. Santos, S. Tomic and M. Beko, \"GTRS-Based Algorithm for UAV Navigation in Indoor Environments Employing Range Measurements and Odometry,\" in IEEE Access, vol. 9, pp. 89120-89132, 2021, doi: 10.1109/ACCESS.2021.3089900. https://ieeexplore.ieee.org/document/9456863</p> <p>[2] R. Santos, J. P. Matos-Carvalho, S. Tomic and M. Beko, \"WLS algorithm for UAV navigation in satellite\u2010less environments,\" in IET Wireless Sensor Systems, 2022, 12, (3-4), p. 93-102, DOI: 10.1049/wss2.12041 IET Digital Library, https://ietresearch.onlinelibrary.wiley.com/doi/full/10.1049/wss2.12041</p>"},{"location":"#license","title":"License","text":"<p>MIT License</p>"},{"location":"dev/","title":"For developers","text":"<p>If you wish to add more features to AutoNAV, feel free to install it in developer mode as follows.</p>"},{"location":"dev/#installing-for-development","title":"Installing for development","text":"<p>With the commands below, one will install all the necessary development dependencies.</p> <pre><code>git clone https://github.com/ricardo-s-santos/AutoNAV.git\ncd autonav\npython -m venv env\nsource env/bin/activate\npip install -e .[devel]\npre-commit install\n</code></pre>"},{"location":"dev/#tests","title":"Tests","text":"<p>The AutoNAV package contains several tests to assess its quality. These tests can be runned with the command:</p> <pre><code>pytest\n</code></pre> <p>A coverage report can also be created with the command:</p> <pre><code>pytest --cov=autonav --cov-report=html\n</code></pre>"},{"location":"functions/","title":"Available Functions and Documentation","text":"<p>Apart from the algorithms, several auxiliary functions are available. In this page, one can find all the available functions and there respective documentation.</p>"},{"location":"functions/#algorithms","title":"Algorithms","text":""},{"location":"functions/#autonav.gtrs","title":"gtrs","text":"<pre><code>gtrs(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    v_max: int,\n    tau: int,\n    gamma: int,\n    noise_seed: int = 1,\n    tol: float = 0.001,\n    n_iter: int = 30,\n    max_lim: float = 1000000.0,\n) -&gt; NDArray\n</code></pre> <p>Executes the GTRS algorithm.</p> <p>See here more details about the GTRS algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>a_i</code> <code>NDArray</code> <p>The true position of the anchors in 3D.</p> required <code>n</code> <code>int</code> <p>The number of anchors.</p> required <code>k</code> <code>int</code> <p>The number of measurements.</p> required <code>sigma</code> <code>float</code> <p>The noise level in meters.</p> required <code>destinations</code> <code>NDArray</code> <p>The intermediate points need for navigation in 3D.</p> required <code>initial_uav_position</code> <code>list</code> <p>The initial UAV position in 3D.</p> required <code>v_max</code> <code>int</code> <p>The maximum velocity that the UAV can fly.</p> required <code>tau</code> <code>int</code> <p>The threshold to reach the destination.</p> required <code>gamma</code> <code>int</code> <p>The smoothing factor.</p> required <code>noise_seed</code> <code>int</code> <p>The seed to generate the noise.</p> <code>1</code> <code>tol</code> <code>float</code> <p>The tolerance for the bisection function.</p> <code>0.001</code> <code>n_iter</code> <code>int</code> <p>The max number of iterations for the bisection function.</p> <code>30</code> <code>max_lim</code> <code>float</code> <p>The maximum value for the interval in the bisection function.</p> <code>1000000.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The estimated trajectory computed using the GTRS algorithm for the given input scenario and the true trajectory that the UAV followed.</p> Source code in <code>autonav/GTRS.py</code> <pre><code>def gtrs(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    v_max: int,\n    tau: int,\n    gamma: int,\n    noise_seed: int = 1,\n    tol: float = 0.001,\n    n_iter: int = 30,\n    max_lim: float = 1000000.0,\n) -&gt; NDArray:\n    \"\"\"Executes the GTRS algorithm.\n\n    [See here more details about the GTRS algorithm.](https://ieeexplore.ieee.org/document/9456863)\n\n    Args:\n        a_i: The true position of the anchors in 3D.\n        n: The number of anchors.\n        k: The number of measurements.\n        sigma: The noise level in meters.\n        destinations: The intermediate points need for navigation in 3D.\n        initial_uav_position: The initial UAV position in 3D.\n        v_max: The maximum velocity that the UAV can fly.\n        tau: The threshold to reach the destination.\n        gamma: The smoothing factor.\n        noise_seed: The seed to generate the noise.\n        tol: The tolerance for the bisection function.\n        n_iter: The max number of iterations for the bisection function.\n        max_lim: The maximum value for the interval in the bisection function.\n\n    Returns:\n        The estimated trajectory computed using the GTRS algorithm for the given input scenario\n          and the true trajectory that the UAV followed.\n    \"\"\"\n    # Validate inputs\n    if size(a_i, axis=1) != n:\n        raise ValueError(\"The length of a_i must be equal to N.\")\n    if k &lt;= 0:\n        raise ValueError(\"K must be positive.\")\n    if sigma &lt; 0 or sigma &gt; 5:\n        raise ValueError(\"Sigma must be between 0 and 5.\")\n    if size(destinations) == 0:\n        raise ValueError(\"Waypoints cannot be empty.\")\n    if size(destinations, axis=1) != 3:\n        raise ValueError(\"Waypoints must contain the 3 coordinates (x, y, z).\")\n    if len(initial_uav_position) != 3:\n        raise ValueError(\"Initial UAV position must contain the 3 coordinates (x, y, z).\")\n    # Test optional inputs\n    if tol &lt; 0:\n        raise ValueError(\"Tolerance must be positive.\")\n    if n_iter &lt; 0:\n        raise ValueError(\"Number of Bisection iterations must be positive.\")\n    if max_lim &lt; 0:\n        raise ValueError(\"The maximum value for the interval in the bisection function must be positive.\")\n    ts = 1  # Time sample in seconds\n    s = eye(6)  # State transition matrix\n    s[0, 3] = ts\n    s[1, 4] = ts\n    s[2, 5] = ts\n    sigma_w = 0.05  # State process noise intensity  # State process noise covariance\n    q = dot(\n        sigma_w**2,\n        (\n            [\n                [ts**3 / 3, 0, 0, ts**2 / 2, 0, 0],\n                [0, ts**3 / 3, 0, 0, ts**2 / 2, 0],\n                [0, 0, ts**3 / 3, 0, 0, ts**2 / 2],\n                [ts**2 / 2, 0, 0, ts, 0, 0],\n                [0, ts**2 / 2, 0, 0, ts, 0],\n                [0, 0, ts**2 / 2, 0, 0, ts],\n            ]\n        ),\n    )\n    x_state = zeros(shape=(6, 1))\n    x_loc = zeros(shape=(3, 1))\n    p = eye(6)\n    qq = 0\n    x_true = initial_uav_position[:]\n    estimated_trajectory = []\n    true_trajectory = []\n    ww = 0\n    n_dest = len(destinations) - 1\n    # Generator to create random numbers (see line 122)\n    gen = random_generator(noise_seed)\n    while ww &lt;= n_dest:\n        distance = math.sqrt(\n            (x_true[0] - destinations[ww][0]) ** 2\n            + (x_true[1] - destinations[ww][1]) ** 2\n            + (x_true[2] - destinations[ww][2]) ** 2\n        )\n        while distance &gt; 1:\n            x = x_true[0:3]\n            # ---------------------------------------------------------------------\n            # Simulation part\n            # ---------------------------------------------------------------------\n            di_k = sqrt(((x[0] - a_i[0, :]) ** 2) + ((x[1] - a_i[1, :]) ** 2) + ((x[2] - a_i[2, :]) ** 2))\n            di_k = array([di_k]).T\n            di_k = di_k + (sigma * gen.standard_normal(size=(n, k)))\n            d_i = median(di_k, axis=1)\n            d_i = array([d_i]).T\n            # ---------------------------------------------------------------------\n            # Estimation part\n            # ---------------------------------------------------------------------\n            a1_loc = zeros(shape=(n, 4))\n            b1_loc = zeros(shape=(n, 1))\n            a_track = zeros(shape=(n + 6, 7))\n            b_track = zeros(shape=(n + 6, 1))\n            w_i_loc = array(sqrt(d_i ** (-1.0) / (sum(d_i ** (-1.0)))))\n            for tt in arange(0, n, 1).reshape(-1):\n                a1_loc[tt] = append(dot(2, a_i[0:3, tt].T), -1)\n                b1_loc[tt] = norm(a_i[0:3, tt]) ** 2 - d_i[tt] ** 2\n            w_loc = diag(w_i_loc.T[0])\n            d_loc = eye(4)\n            d_loc[3, 3] = 0\n            f_loc = array([0, 0, 0, -1.0 / 2.0]).reshape(4, 1)\n            a_loc = dot(w_loc, a1_loc)\n            b_loc = dot(w_loc, b1_loc)\n            if qq != 0:\n                aux = dot(s, p)\n                p_pred = dot(aux, s.T) + q\n                x_pred = dot(s, x_state[0:6, qq - 1])\n                x_pred = x_pred.reshape(len(x_pred), 1)\n                a1_track = zeros(shape=(n, 7))\n                b1_track = zeros(shape=(n, 1))\n                for tt in arange(0, n, 1).reshape(-1):\n                    a1_track[tt] = concatenate((dot(2, a_i[0:3, tt].T), zeros(size(x, 0)), [-1]), axis=0)\n                    b1_track[tt] = norm(a_i[0:3, tt]) ** 2 - abs(d_i[tt] ** 2)\n                left_matrix = sqrtm(inv(p_pred))\n                right_matrix = zeros((size(x_state, 0), 1))\n                a1_track = concatenate((a1_track, concatenate((left_matrix, right_matrix), axis=1)), axis=0)\n                a1_track[a1_track == math.inf] = 0\n                inf_p_pred = array(sqrtm(inv(p_pred)))\n                inf_p_pred[inf_p_pred == math.inf] = 0\n                b1_track = concatenate((b1_track, dot(inf_p_pred, x_pred)), axis=0)\n                a = dot(math.sqrt(1.0 / 2.0), w_i_loc.T)\n                b = dot(math.sqrt(1.0 / 8.0), ones((1, size(x_state, 0))))\n                w_track = concatenate((a, b), axis=1)\n                w_track = eye(size(w_track, 1)) * w_track\n                d_track = zeros((7, 7))\n                d_track[0, 0] = 1\n                d_track[1, 1] = 1\n                d_track[2, 2] = 1\n                f_track = array([0, 0, 0, 0, 0, 0, -1.0 / 2.0]).reshape(7, 1)\n                a_track = dot(w_track, a1_track)\n                b_track = dot(w_track, b1_track)\n            eigen_values = _calc_eigen(a_loc, d_loc)\n            eig_1 = max(eigen_values)\n            min_lim = -1.0 / eig_1\n            lambda_loc = _bisection_fun(min_lim, max_lim, tol, n_iter, a_loc, d_loc, b_loc, f_loc)\n            y_hat_loc = solve(\n                (dot(a_loc.T, a_loc) + dot(lambda_loc, d_loc) + dot(1e-06, eye(size(a_loc, 1)))),\n                (dot(a_loc.T, b_loc) - dot(lambda_loc, f_loc)),\n            )\n            if qq == 0:\n                x_loc[0:3, qq] = real(y_hat_loc[0:3, 0])\n                x_state[0:6, qq] = concatenate((x_loc[0:3, qq], zeros(3)), axis=0)\n                p = eye(6)\n                estimated_trajectory.append(x_loc[0:3, qq])\n            else:\n                x_loc = insert(x_loc, qq, real(y_hat_loc[0:3, 0]), axis=1)\n                eigen_values = _calc_eigen(a_track, d_track)\n                eig_1 = max(eigen_values)\n                min_lim = -1.0 / eig_1\n                lambda_track = _bisection_fun(min_lim, max_lim, tol, n_iter, a_track, d_track, b_track, f_track)\n                y_hat_track = solve(\n                    (dot(a_track.T, a_track) + dot(lambda_track, d_track) + dot(1e-06, eye(size(a_track, 1)))),\n                    (dot(a_track.T, b_track) - dot(lambda_track, f_track)),\n                )\n                x_state = concatenate((x_state, zeros((size(x_state, 0), 1))), axis=1)\n                x_state[0:6, qq] = concatenate((real(y_hat_track[arange(0, size(x_state, 0))])), axis=0)\n                lk1 = subtract(x_state[0:6, qq], x_state[0:6, qq - 1]).reshape((6, 1))\n                lk2 = subtract(x_state[0:6, qq], x_state[0:6, qq - 1]).reshape((6, 1)).T\n                p = matmul(lk1, lk2)\n                estimated_trajectory.append(x_loc[0:3, qq])\n            true_trajectory.append(x_true[:])\n            uav_velocity = _velocity(x_loc[0:3, qq], destinations[ww, :], v_max, tau, gamma)\n            x_true[0] = x_true[0] + uav_velocity[0]\n            x_true[1] = x_true[1] + uav_velocity[1]\n            x_true[2] = x_true[2] + uav_velocity[2]\n            distance = math.sqrt(\n                (x_true[0] - destinations[ww][0]) ** 2\n                + (x_true[1] - destinations[ww][1]) ** 2\n                + (x_true[2] - destinations[ww][2]) ** 2\n            )\n            qq += 1\n        ww += 1\n    return array([array(estimated_trajectory), array(true_trajectory)])\n</code></pre>"},{"location":"functions/#autonav.wls","title":"wls","text":"<pre><code>wls(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    v_max: int,\n    tau: int,\n    gamma: int,\n    noise_seed: int = 1,\n) -&gt; NDArray\n</code></pre> <p>Executes the WLS algorithm.</p> <p>[See here more details about the WLS algorithm.] (https://ietresearch.onlinelibrary.wiley.com/doi/full/10.1049/wss2.12041)</p> <p>Parameters:</p> Name Type Description Default <code>a_i</code> <code>NDArray</code> <p>The true position of the anchors in 3D.</p> required <code>n</code> <code>int</code> <p>The number of anchors.</p> required <code>k</code> <code>int</code> <p>The number of measurements.</p> required <code>sigma</code> <code>float</code> <p>The noise level in meters.</p> required <code>destinations</code> <code>NDArray</code> <p>The intermediate points need for navigation in 3D.</p> required <code>initial_uav_position</code> <code>list</code> <p>The initial UAV position in 3D.</p> required <code>v_max</code> <code>int</code> <p>The maximum velocity that the UAV can fly.</p> required <code>tau</code> <code>int</code> <p>The threshold to reach the destination.</p> required <code>gamma</code> <code>int</code> <p>The smoothing factor.</p> required <code>noise_seed</code> <code>int</code> <p>The seed to generate the noise.</p> <code>1</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The estimated trajectory computed using the WLS algorithm for the given input scenario and the true trajectory that the UAV followed.</p> Source code in <code>autonav/WLS.py</code> <pre><code>def wls(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    v_max: int,\n    tau: int,\n    gamma: int,\n    noise_seed: int = 1,\n) -&gt; NDArray:\n    \"\"\"Executes the WLS algorithm.\n\n    [See here more details about the WLS algorithm.]\n    (https://ietresearch.onlinelibrary.wiley.com/doi/full/10.1049/wss2.12041)\n\n    Args:\n        a_i: The true position of the anchors in 3D.\n        n: The number of anchors.\n        k: The number of measurements.\n        sigma: The noise level in meters.\n        destinations: The intermediate points need for navigation in 3D.\n        initial_uav_position: The initial UAV position in 3D.\n        v_max: The maximum velocity that the UAV can fly.\n        tau: The threshold to reach the destination.\n        gamma: The smoothing factor.\n        noise_seed: The seed to generate the noise.\n\n    Returns:\n        The estimated trajectory computed using the WLS algorithm for the given input scenario\n          and the true trajectory that the UAV followed.\n    \"\"\"\n    # Validate inputs\n    if size(a_i, axis=1) != n:\n        raise ValueError(\"The length of a_i must be equal to N.\")\n    if k &lt;= 0:\n        raise ValueError(\"K must be positive.\")\n    if sigma &lt; 0 or sigma &gt; 5:\n        raise ValueError(\"Sigma must be between 0 and 5.\")\n    if size(destinations) == 0:\n        raise ValueError(\"Waypoints cannot be empty.\")\n    if size(destinations, axis=1) != 3:\n        raise ValueError(\"Waypoints must contain the 3 coordinates (x, y, z).\")\n    if len(initial_uav_position) != 3:\n        raise ValueError(\"Initial UAV position must contain the 3 coordinates (x, y, z).\")\n    x_true = initial_uav_position[:]\n    ww = 0\n    n_dest = len(destinations) - 1\n    estimated_trajectory = []\n    true_trajectory = []\n    # Generator to create random numbers (see line 65)\n    gen = random_generator(noise_seed)\n    while ww &lt;= n_dest:\n        distance = math.sqrt(\n            (x_true[0] - destinations[ww][0]) ** 2\n            + (x_true[1] - destinations[ww][1]) ** 2\n            + (x_true[2] - destinations[ww][2]) ** 2\n        )\n        while distance &gt; 1:\n            x = x_true[0:3]\n            # ---------------------------------------------------------------------\n            # Simulation part\n            # ---------------------------------------------------------------------\n            di_k = sqrt(((x[0] - a_i[0, :]) ** 2) + ((x[1] - a_i[1, :]) ** 2) + ((x[2] - a_i[2, :]) ** 2))\n            di_k = array([di_k]).T\n            di_k = di_k + (sigma * gen.standard_normal(size=(n, k)))\n            d_i = median(di_k, axis=1)\n            d_i = array([d_i]).T\n            # ---------------------------------------------------------------------\n            # Estimation part\n            # ---------------------------------------------------------------------\n            xi_est = zeros(shape=(3, n))\n            phi_i = zeros(shape=(n, 1))\n            alpha_i = zeros(shape=(n, 1))\n            for ii in range(0, n):\n                kk = [ii + 1]\n                for jj in range(0, n):\n                    total = 0\n                    if a_i[0, ii] == a_i[0, jj]:\n                        total += 1\n                    if a_i[1, ii] == a_i[1, jj]:\n                        total += 1\n                    if ii != jj and total &gt; 0:\n                        kk.append(jj + 1)\n                a2 = zeros(shape=(len(array(list(itertools.combinations(kk, 2)))), 3))\n                b2 = zeros(shape=(len(array(list(itertools.combinations(kk, 2)))), 1))\n                for uu in range(0, len(array(list(itertools.combinations(kk, 2))))):\n                    combinations = array(list(itertools.combinations(kk, 2)))\n                    gg = combinations[uu, 0]\n                    hh = combinations[uu, 1]\n                    a2[uu, :] = 2 * (a_i[0:3, gg - 1] - a_i[0:3, hh - 1]).T\n                    b2[uu] = (\n                        d_i[hh - 1] ** 2 - d_i[gg - 1] ** 2 - norm(a_i[0:3, hh - 1]) ** 2 + norm(a_i[0:3, gg - 1]) ** 2\n                    )\n                xi_est[:, [ii]] = solve(dot(a2.T, a2) + (1 * 10 ** (-6)) * eye(3), dot(a2.T, b2))\n                di_xy = norm(xi_est[0:2, 0])\n                xi_est[2][ii] = (cmath.sqrt((d_i[0] ** 2)[0] - (di_xy**2)).real) + (\n                    cmath.sqrt((d_i[0] ** 2)[0] - (di_xy**2)).imag\n                )\n                phi_i[ii] = math.atan2((xi_est[1][ii] - a_i[1, ii]), (xi_est[0][ii] - a_i[0, ii])) * 180 / math.pi\n                alpha_i[ii] = (\n                    math.acos((xi_est[2][ii] - a_i[2, ii]) / (norm(xi_est[:, ii] - a_i[:, ii]))) * 180 / math.pi\n                )\n            u_i_1 = cos((phi_i * math.pi) / 180).T\n            u_i_2 = sin((alpha_i * math.pi) / 180).T\n            u_i_3 = sin((phi_i * math.pi) / 180).T\n            u_i_4 = cos((alpha_i * math.pi) / 180).T\n            u_i = zeros(shape=(3, n))\n            u_i[0, :] = u_i_1 * u_i_2\n            u_i[1, :] = u_i_3 * u_i_2\n            u_i[2, :] = u_i_4\n            a_1 = u_i.T\n            b_1 = d_i + (sum(u_i * a_i).T.reshape(n, 1))\n            w_i = asarray((1 / d_i) / (sum(1 / d_i)))\n            w = asarray(eye(n) * scimath.sqrt(w_i))\n            a_loc = dot(w, a_1)\n            b_loc = dot(w, b_1)\n            x_est = asarray(solve(dot(a_loc.T, a_loc) + (1 * 10 ** (-6)) * eye(3), dot(a_loc.T, b_loc)))\n            estimated_trajectory.append(x_est[:, 0])\n            true_trajectory.append(x_true[:])\n            uav_velocity = _velocity(x_est[:, 0], destinations[ww, :], v_max, tau, gamma)\n            x_true[0] = x_true[0] + uav_velocity[0]\n            x_true[1] = x_true[1] + uav_velocity[1]\n            x_true[2] = x_true[2] + uav_velocity[2]\n            distance = math.sqrt(\n                (x_true[0] - destinations[ww][0]) ** 2\n                + (x_true[1] - destinations[ww][1]) ** 2\n                + (x_true[2] - destinations[ww][2]) ** 2\n            )\n        ww += 1\n    return array([array(estimated_trajectory), array(true_trajectory)])\n</code></pre>"},{"location":"functions/#plots","title":"Plots","text":"<p>This module contains the plotting functions.</p>"},{"location":"functions/#autonav.plots.plot_rmse","title":"plot_rmse","text":"<pre><code>plot_rmse(\n    estimated_trajectories: List[NDArray],\n    true_trajectories: List[NDArray],\n    names_of_the_algorithms: Optional[List[str]] = None,\n) -&gt; NDArray\n</code></pre> <p>Plots the root mean squared error along the trajectory for one or more algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>estimated_trajectories</code> <code>List[NDArray]</code> <p>The estimated trajectory that the UAV followed.</p> required <code>true_trajectories</code> <code>List[NDArray]</code> <p>The true trajectory that the UAV followed.</p> required <code>names_of_the_algorithms</code> <code>Optional[List[str]]</code> <p>The names of the algorithms in the same order as in estimated_trajectories.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>An NDArray object containing the RMSE comparison.</p> Source code in <code>autonav/plots.py</code> <pre><code>def plot_rmse(\n    estimated_trajectories: List[NDArray],\n    true_trajectories: List[NDArray],\n    names_of_the_algorithms: Optional[List[str]] = None,\n) -&gt; NDArray:\n    \"\"\"Plots the root mean squared error along the trajectory for one or more algorithms.\n\n    Args:\n       estimated_trajectories: The estimated trajectory that the UAV followed.\n       true_trajectories: The true trajectory that the UAV followed.\n       names_of_the_algorithms: The names of the algorithms in the same order as in estimated_trajectories.\n\n    Returns:\n        An NDArray object containing the RMSE comparison.\n    \"\"\"\n    # User didn't input names_of_the_algorithms\n    if names_of_the_algorithms is None:\n        names_of_the_algorithms = [\"GTRS\", \"WLS\"]\n    if len(estimated_trajectories) == len(true_trajectories):\n        fig, axs = plt.subplots(len(estimated_trajectories), sharey=True)\n        # Space between subplots\n        fig.tight_layout(pad=5.0)\n        for i in range(len(estimated_trajectories)):\n            rmse = compute_rmse(estimated_trajectories[i][:, :], true_trajectories[i][:, :])\n            axs[i].plot(rmse)\n            axs[i].set_title(\"RMSE \" + names_of_the_algorithms[i])\n        for ax in axs.flat:\n            ax.set(xlabel=\"Iteration\", ylabel=\"RMSE\")\n        return axs\n    else:\n        raise ValueError(\"The number of algorithms must be the same in estimated_trajectories and true_trajectories.\")\n</code></pre>"},{"location":"functions/#autonav.plots.plot_trajectories","title":"plot_trajectories","text":"<pre><code>plot_trajectories(\n    ideal_trajectory: NDArray,\n    estimated_trajectories: List[NDArray],\n    a_i: NDArray,\n    names_of_the_algorithms: Optional[List[str]] = None,\n) -&gt; list\n</code></pre> <p>Plots the ideal and estimated trajectory for one or more algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>ideal_trajectory</code> <code>NDArray</code> <p>The ideal trajectory that the UAV is supposed to follow.</p> required <code>estimated_trajectories</code> <code>List[NDArray]</code> <p>The estimated trajectory that the UAV followed using the GTRS algorithm.</p> required <code>names_of_the_algorithms</code> <code>Optional[List[str]]</code> <p>The names of the algorithms in the same order as in estimated_trajectories.</p> <code>None</code> <code>a_i</code> <code>NDArray</code> <p>The position of the anchors.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of Matplotlib Axes object containing the ideal and estimated trajectory comparison.</p> Source code in <code>autonav/plots.py</code> <pre><code>def plot_trajectories(\n    ideal_trajectory: NDArray,\n    estimated_trajectories: List[NDArray],\n    a_i: NDArray,\n    names_of_the_algorithms: Optional[List[str]] = None,\n) -&gt; list:\n    \"\"\"Plots the ideal and estimated trajectory for one or more algorithms.\n\n    Args:\n        ideal_trajectory: The ideal trajectory that the UAV is supposed to follow.\n        estimated_trajectories: The estimated trajectory that the UAV followed using the GTRS algorithm.\n        names_of_the_algorithms: The names of the algorithms in the same order as in estimated_trajectories.\n        a_i: The position of the anchors.\n\n    Returns:\n        A list of Matplotlib Axes object containing the ideal and estimated trajectory comparison.\n    \"\"\"\n    # User didn't input names_of_the_algorithms\n    if names_of_the_algorithms is None:\n        names_of_the_algorithms = [\"GTRS\", \"WLS\"]\n    if len(estimated_trajectories) == len(names_of_the_algorithms):\n        axes = []\n        for j in range(len(estimated_trajectories)):\n            plt.figure(j)  # New figure foreach algorithm\n            ax = plt.axes(projection=\"3d\")\n            a_i_label = \"a_i\"\n            for i in range(0, a_i.shape[1]):\n                ax.plot(\n                    a_i[0][i],\n                    a_i[1][i],\n                    a_i[2][i],\n                    marker=\"s\",\n                    markersize=10,\n                    markeredgecolor=\"black\",\n                    markerfacecolor=\"black\",\n                    label=a_i_label,\n                )\n                a_i_label = \"_nolegend_\"  # Legend only in the first iteration\n            ax.plot(\n                ideal_trajectory[:, 0],\n                ideal_trajectory[:, 1],\n                ideal_trajectory[:, 2],\n                color=\"green\",\n                label=\"Ideal Trajectory\",\n                linewidth=3.0,\n                alpha=0.7,\n            )\n            ax.plot(\n                estimated_trajectories[j][:, 0],\n                estimated_trajectories[j][:, 1],\n                estimated_trajectories[j][:, 2],\n                label=\"Estimated Trajectory \" + names_of_the_algorithms[j],\n                color=\"red\",\n                alpha=1.0,\n            )\n            ax.set_title(\"Estimated Trajectory \" + names_of_the_algorithms[j])\n            ax.set_xlabel(\"Width (m)\")\n            ax.set_ylabel(\"Length (m)\")\n            ax.set(zlabel=\"Heigth (m)\")\n            ax.legend()\n            axes.append(ax)\n        return axes\n    else:\n        raise ValueError(\n            \"The number of algorithms must be the same in estimated_trajectories and names_of_the_algorithms.\"\n        )\n</code></pre>"},{"location":"functions/#metrics","title":"Metrics","text":"<p>This module contains the metrics functions.</p>"},{"location":"functions/#autonav.metrics.compute_armse","title":"compute_armse","text":"<pre><code>compute_armse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; float\n</code></pre> <p>This function computes the average root mean squared error between the true and estimated trajectory of the UAV.</p> <p>Parameters:</p> Name Type Description Default <code>estimated_trajectory</code> <code>NDArray</code> <p>The estimated position of the UAV.</p> required <code>true_trajectory</code> <code>NDArray</code> <p>The true position of the UAV.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The average root mean squared error between the true and the estimated positions of the UAV.</p> Source code in <code>autonav/metrics.py</code> <pre><code>def compute_armse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; float:\n    \"\"\"This function computes the average root mean squared error between the true and estimated trajectory of the UAV.\n\n    Args:\n        estimated_trajectory: The estimated position of the UAV.\n        true_trajectory: The true position of the UAV.\n\n    Returns:\n        The average root mean squared error between the true and the estimated positions of the UAV.\n    \"\"\"\n    rmse = compute_rmse(estimated_trajectory, true_trajectory)\n    if len(rmse) != 0:\n        armse = sum(rmse) / len(rmse)\n    else:\n        raise ZeroDivisionError(\"RMSE is empty!\")\n    return armse\n</code></pre>"},{"location":"functions/#autonav.metrics.compute_rmse","title":"compute_rmse","text":"<pre><code>compute_rmse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; list\n</code></pre> <p>Computes the root mean squared error between the true and estimated trajectory of the UAV.</p> <p>Parameters:</p> Name Type Description Default <code>estimated_trajectory</code> <code>NDArray</code> <p>The estimated position of the UAV.</p> required <code>true_trajectory</code> <code>NDArray</code> <p>The true position of the UAV.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The average root mean squared error between the true and the estimated positions of the UAV.</p> Source code in <code>autonav/metrics.py</code> <pre><code>def compute_rmse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; list:\n    \"\"\"Computes the root mean squared error between the true and estimated trajectory of the UAV.\n\n    Args:\n        estimated_trajectory: The estimated position of the UAV.\n        true_trajectory: The true position of the UAV.\n\n    Returns:\n        The average root mean squared error between the true and the estimated positions of the UAV.\n    \"\"\"\n    rmse = []\n    # Trajectories must have the same length for comparison\n    if len(estimated_trajectory) == len(true_trajectory):\n        for i in range(len(estimated_trajectory)):\n            norm = sqrt(\n                (true_trajectory[i][0] - estimated_trajectory[i][0]) ** 2\n                + (true_trajectory[i][1] - estimated_trajectory[i][1]) ** 2\n                + (true_trajectory[i][2] - estimated_trajectory[i][2]) ** 2\n            )\n            rmse.append(sqrt(norm))\n    return rmse\n</code></pre>"},{"location":"functions/#other-functions","title":"Other functions","text":"<p>This module contains the functions to read the path file.</p>"},{"location":"functions/#autonav.file_handlers.readpathfile","title":"readpathfile","text":"<pre><code>readpathfile(filename: str) -&gt; NDArray\n</code></pre> <p>Reads the path file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to read.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The waypoints needed to guide the drone.</p> Source code in <code>autonav/file_handlers.py</code> <pre><code>def readpathfile(filename: str) -&gt; NDArray:\n    \"\"\"Reads the path file.\n\n    Args:\n        filename: The name of the file to read.\n\n    Returns:\n        The waypoints needed to guide the drone.\n    \"\"\"\n    positions = []\n    if os.path.isfile(filename):  # See if file exists\n        with open(filename, \"r\") as file:\n            csv_file = csv.reader(file)\n            for line in csv_file:\n                positions.append([float(x) for x in line])\n    else:\n        raise FileNotFoundError(\"File not found, please check path.\") from None\n    return array(positions)\n</code></pre>"},{"location":"generated/gallery/","title":"Examples","text":""},{"location":"generated/gallery/#examples","title":"Examples","text":"<p> GTRS example in 3D </p> <p> Extract RMSE and ARMSE metrics </p> <p> WLS example in 3D </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:14.911 total execution time for generated_gallery files:</p> <p>+----------------------------------------------------------------+-----------+--------+ | plot_gtrs_1 (docs/examples/plot_gtrs_1.py) | 00:07.368 | 0.0 MB | +----------------------------------------------------------------+-----------+--------+ | plot_rmse (docs/examples/plot_rmse.py)       | 00:06.569 | 0.0 MB | +----------------------------------------------------------------+-----------+--------+ | plot_wls_1 (docs/examples/plot_wls_1.py)    | 00:00.973 | 0.0 MB | +----------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plot_gtrs_1/","title":"GTRS example in 3D","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_gtrs_1/#gtrs-example-in-3d","title":"GTRS example in 3D","text":"<p>First, the required dependencies are imported:</p> <pre><code>from autonav import gtrs\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories\nfrom numpy import array\n</code></pre> <p>The next step is to define the simulation parameters:</p> <pre><code># Area border\nb = 200\n# Number of anchors\nn = 8\n# Position of the anchors\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\n# Number of measurement samples\nk = 50\n# Noise standard deviation\nsigma = 1\n# Maximum velocity allowed to the UAV\nv_max = b / 100\n# Distance threshold\ntau = b / 50\n# Smoothing factor\ngamma = b / 100\n# Initial position of the UAV\ninitial_uav_position = [10, 10, 5]\n# File containing the waypoints\ndestinations = readpathfile(\"Path.csv\")\n</code></pre> <p>Finally, one can invoke the [<code>gtrs</code>] function and plot the estimated trajectory:</p> <pre><code>[estimated_trajectory, true_trajectory] = gtrs(a_i, n, k, sigma, destinations, initial_uav_position, v_max, tau, gamma)\nplt_obj = plot_trajectories(destinations, [estimated_trajectory], a_i, ['GTRS'])\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  7.368 seconds)</p> <p> Download Python source code: plot_gtrs_1.py</p> <p> Download Jupyter notebook: plot_gtrs_1.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_rmse/","title":"Extract RMSE and ARMSE metrics","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_rmse/#extract-rmse-and-armse-metrics","title":"Extract RMSE and ARMSE metrics","text":"<p>First, the required dependencies are imported:</p> <pre><code>from autonav import gtrs, wls\nfrom autonav.file_handlers import readpathfile\nfrom autonav.metrics import compute_armse\nfrom autonav.plots import plot_rmse\nfrom numpy import array\n</code></pre> <p>The next step is to define the simulation parameters:</p> <pre><code># Area border\nb = 200\n# Number of anchors\nn = 8\n# Position of the anchors\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\n# Number of measurement samples\nk = 50\n# Noise standard deviation\nsigma = 1\n# Maximum velocity allowed to the UAV\nv_max = b / 100\n# Distance threshold\ntau = b / 50\n# Smoothing factor\ngamma = b / 100\n# Initial position of the UAV\ninitial_uav_position = [10, 10, 5]\n# File containing the waypoints\ndestinations = readpathfile(\"Path.csv\")\n</code></pre> <p>Invoke the [<code>gtrs</code>] and [<code>wls</code>] functions and afterwards the [<code>compute_armse</code>] and [<code>plot_rmse</code>] as follows to compute the ARMSE and plot the RMSE, respectively:</p> <pre><code>[estimated_trajectory_gtrs, true_trajectory_gtrs] = gtrs(a_i, n, k, sigma, destinations, initial_uav_position, v_max, tau, gamma)\n[estimated_trajectory_wls, true_trajectory_wls] = wls(a_i, n, k, sigma, destinations, initial_uav_position, v_max, tau, gamma)\narmsegtrs = print(f'GTRS ARMSE: {compute_armse(estimated_trajectory_gtrs, true_trajectory_gtrs)}')\narmsewls = print(f'WLS ARMSE: {compute_armse(estimated_trajectory_wls, true_trajectory_wls)}')\nplt_obj = plot_rmse([estimated_trajectory_gtrs, estimated_trajectory_wls],[true_trajectory_gtrs, true_trajectory_wls])\n</code></pre> <p></p> <p>Out:</p> <pre><code>GTRS ARMSE: 0.5858874524393974\nWLS ARMSE: 0.5778477498235293\n</code></pre> <p>Total running time of the script: ( 0 minutes  6.569 seconds)</p> <p> Download Python source code: plot_rmse.py</p> <p> Download Jupyter notebook: plot_rmse.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_wls_1/","title":"WLS example in 3D","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_wls_1/#wls-example-in-3d","title":"WLS example in 3D","text":"<p>First, the required dependencies are imported:</p> <pre><code>from autonav import wls\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories\nfrom numpy import array\n</code></pre> <p>The next step is to define the simulation parameters:</p> <pre><code># Area border\nb = 200\n# Number of anchors\nn = 8\n# Position of the anchors\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\n# Number of measurement samples\nk = 50\n# Noise standard deviation\nsigma = 1\n# Maximum velocity allowed to the UAV\nv_max = b / 100\n# Distance threshold\ntau = b / 50\n# Smoothing factor\ngamma = b / 100\n# Initial position of the UAV\ninitial_uav_position = [10, 10, 5]\n# File containing the waypoints\ndestinations = readpathfile(\"Path.csv\")\n</code></pre> <p>Finally, one can invoke the [<code>wls</code>] and function and plot the estimated trajectory:</p> <pre><code>[estimated_trajectory, true_trajectory] = wls(a_i, n, k, sigma, destinations, initial_uav_position, v_max, tau, gamma)\nplt_obj = plot_trajectories(destinations, [estimated_trajectory], a_i, ['WLS'])\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.973 seconds)</p> <p> Download Python source code: plot_wls_1.py</p> <p> Download Jupyter notebook: plot_wls_1.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"}]}